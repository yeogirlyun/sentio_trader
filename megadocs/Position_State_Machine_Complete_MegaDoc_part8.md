# Position State Machine Complete Implementation

**Part 8 of 8**

**Generated**: 2025-09-22 01:45:57
**Source Directory**: /Users/yeogirlyun/C++/sentio_trader
**Description**: Comprehensive requirements document and source code analysis for implementing a theoretically sound Position State Machine to replace ad-hoc trading logic with systematic state-based decision making. Includes complete requirements specification, current system analysis, and integration architecture.

**Part 8 Files**: See file count below

---

## ðŸ“‹ **TABLE OF CONTENTS**

36. [src/backend/evaluate_signal_fixed.cpp](#file-36)
37. [src/backend/leverage_data_generator.cpp](#file-37)
38. [src/backend/leverage_manager.cpp](#file-38)
39. [src/backend/portfolio_manager.cpp](#file-39)

---

## ðŸ“„ **FILE 36 of 39**: src/backend/evaluate_signal_fixed.cpp

**File Information**:
- **Path**: `src/backend/evaluate_signal_fixed.cpp`

- **Size**: 88 lines
- **Modified**: 2025-09-21 22:02:21

- **Type**: .cpp

```text
// FIXED evaluate_signal method that eliminates phantom sell orders
// This completely replaces the buggy implementation

BackendComponent::TradeOrder BackendComponent::evaluate_signal(
    const SignalOutput& signal, const Bar& bar) {

    // CRITICAL BUG FIX: Use Adaptive Portfolio Manager to eliminate phantom sell orders
    utils::log_debug("EVALUATING SIGNAL with Adaptive Portfolio Manager: Symbol=" + signal.symbol + 
                    ", Probability=" + std::to_string(signal.probability) + 
                    ", Confidence=" + std::to_string(signal.confidence));
    
    // Convert SignalOutput and Bar to adaptive portfolio manager format
    sentio::SignalOutput adaptive_signal = signal;  // Should be compatible
    sentio::Bar adaptive_bar = bar;                 // Should be compatible
    
    // Use the Adaptive Portfolio Manager for intelligent trade decisions
    auto adaptive_orders = adaptive_portfolio_manager_->execute_adaptive_trade(adaptive_signal, adaptive_bar);
    
    if (adaptive_orders.empty()) {
        utils::log_warning("No orders generated by Adaptive Portfolio Manager");
        TradeOrder hold_order;
        hold_order.action = TradeAction::HOLD;
        hold_order.symbol = signal.symbol;
        hold_order.timestamp_ms = signal.timestamp_ms;
        hold_order.bar_index = signal.bar_index;
        hold_order.execution_reason = "No valid trade opportunities - PHANTOM ORDERS PREVENTED";
        hold_order.before_state = portfolio_manager_->get_state();
        hold_order.after_state = portfolio_manager_->get_state();
        return hold_order;
    }
    
    // Convert the first adaptive order to BackendComponent::TradeOrder
    const auto& adaptive_order = adaptive_orders[0];
    
    TradeOrder order;
    order.timestamp_ms = signal.timestamp_ms;
    order.bar_index = signal.bar_index;
    order.symbol = adaptive_order.symbol;
    order.signal_probability = signal.probability;
    order.signal_confidence = signal.confidence;
    order.price = adaptive_order.price;
    order.quantity = adaptive_order.quantity;
    order.trade_value = adaptive_order.trade_value;
    order.fees = adaptive_order.fees;
    order.execution_reason = adaptive_order.execution_reason;
    order.before_state = portfolio_manager_->get_state();
    
    // Convert action enum
    switch (adaptive_order.action) {
        case sentio::TradeAction::BUY:
            order.action = TradeAction::BUY;
            break;
        case sentio::TradeAction::SELL:
            order.action = TradeAction::SELL;
            break;
        case sentio::TradeAction::HOLD:
        default:
            order.action = TradeAction::HOLD;
            break;
    }
    
    // CRITICAL: If this is a sell order, validate it won't be a phantom order
    if (order.action == TradeAction::SELL) {
        if (!portfolio_manager_->has_position(order.symbol)) {
            utils::log_error("PHANTOM ORDER PREVENTED: Attempted to sell non-existent position " + order.symbol);
            order.action = TradeAction::HOLD;
            order.execution_reason = "PHANTOM ORDER PREVENTED - Position does not exist";
        } else {
            auto position = portfolio_manager_->get_position(order.symbol);
            if (position.quantity < order.quantity) {
                utils::log_error("PHANTOM ORDER PREVENTED: Insufficient quantity to sell " + order.symbol);
                order.action = TradeAction::HOLD;
                order.execution_reason = "PHANTOM ORDER PREVENTED - Insufficient quantity";
            }
        }
    }
    
    order.after_state = portfolio_manager_->get_state();
    
    utils::log_info("SIGNAL EVALUATION COMPLETE: Action=" + 
                   (order.action == TradeAction::BUY ? "BUY" : 
                    order.action == TradeAction::SELL ? "SELL" : "HOLD") + 
                   ", Symbol=" + order.symbol + 
                   ", Quantity=" + std::to_string(order.quantity) + 
                   ", Reason=" + order.execution_reason);
    
    return order;
}

```

## ðŸ“„ **FILE 37 of 39**: src/backend/leverage_data_generator.cpp

**File Information**:
- **Path**: `src/backend/leverage_data_generator.cpp`

- **Size**: 173 lines
- **Modified**: 2025-09-21 16:50:03

- **Type**: .cpp

```text
#include "backend/leverage_data_generator.h"
#include "backend/leverage_types.h"
#include <cmath>
#include <stdexcept>
#include <algorithm>

namespace sentio {

LeverageDataGenerator::LeverageDataGenerator(double daily_decay_rate, double expense_ratio)
    : daily_decay_rate_(daily_decay_rate),
      daily_expense_rate_(expense_ratio / 252.0) { // Approximate trading days per year
}

std::vector<Bar> LeverageDataGenerator::generate_series(const std::vector<Bar>& qqq_data, 
                                                      const std::string& symbol) {
    if (qqq_data.empty()) {
        throw std::invalid_argument("QQQ data cannot be empty");
    }
    
    // Get leverage specification
    LeverageSpec spec = get_leverage_spec(symbol);
    if (spec.type == InstrumentType::NEUTRAL) {
        throw std::runtime_error("Cannot generate data for unknown symbol: " + symbol);
    }
    
    // Cannot generate data for base instrument (QQQ)
    if (spec.type == InstrumentType::LONG_1X && !spec.is_inverse) {
        throw std::runtime_error("Cannot generate data for base instrument: " + symbol);
    }
    
    std::vector<Bar> leverage_series;
    leverage_series.reserve(qqq_data.size());
    
    // Initialize starting price for the leveraged ETF
    // Use a reasonable starting price (e.g., $100 for TQQQ, $50 for SQQQ)
    double starting_price = 100.0;
    if (spec.is_inverse) {
        starting_price = 50.0; // Inverse ETFs typically start lower
    }
    
    double prev_lev_close = starting_price;
    
    // Process each bar using daily return compounding
    for (size_t i = 1; i < qqq_data.size(); ++i) {
        const auto& prev_qqq_bar = qqq_data[i-1];
        const auto& curr_qqq_bar = qqq_data[i];
        
        // 1. Calculate the daily return of the base asset (QQQ)
        double qqq_daily_return = calculate_daily_return(prev_qqq_bar.close, curr_qqq_bar.close);
        
        // 2. Apply leverage factor to daily return
        double leveraged_return = apply_leverage_factor(qqq_daily_return, spec);
        
        // 3. Apply daily costs (decay + expense ratio)
        double total_daily_costs = calculate_daily_costs();
        
        // 4. Calculate the new closing price for the leveraged ETF
        double current_lev_close = prev_lev_close * (1.0 + leveraged_return - total_daily_costs);
        current_lev_close = validate_price(current_lev_close);
        
        // 5. Generate theoretical OHLC by scaling QQQ's intraday movements
        Bar lev_bar = generate_bar_ohlc(curr_qqq_bar, prev_lev_close, spec);
        lev_bar.close = current_lev_close;
        
        leverage_series.push_back(lev_bar);
        prev_lev_close = current_lev_close;
    }
    
    return leverage_series;
}

std::map<std::string, std::vector<Bar>> LeverageDataGenerator::generate_all_series(
    const std::vector<Bar>& qqq_data) {
    
    std::map<std::string, std::vector<Bar>> all_series;
    
    // Generate series for all supported leverage instruments
    auto all_symbols = LeverageRegistry::instance().get_all_symbols();
    
    for (const auto& symbol : all_symbols) {
        // Skip base instrument (QQQ)
        if (symbol == "QQQ") continue;
        
        try {
            all_series[symbol] = generate_series(qqq_data, symbol);
        } catch (const std::exception& e) {
            // Log error but continue with other symbols
            // In a real implementation, you might want to log this
            continue;
        }
    }
    
    return all_series;
}

LeverageSpec LeverageDataGenerator::get_leverage_spec(const std::string& symbol) const {
    return LeverageRegistry::instance().get_spec(symbol);
}

bool LeverageDataGenerator::is_supported_symbol(const std::string& symbol) const {
    auto spec = get_leverage_spec(symbol);
    return spec.type != InstrumentType::NEUTRAL && symbol != "QQQ";
}

Bar LeverageDataGenerator::generate_bar_ohlc(const Bar& qqq_bar, double prev_lev_close, 
                                           const LeverageSpec& spec) const {
    Bar lev_bar;
    lev_bar.timestamp_ms = qqq_bar.timestamp_ms;
    lev_bar.symbol = spec.symbol;
    
    // Calculate intraday movement ratios from QQQ
    double open_ratio = (qqq_bar.open - qqq_bar.close) / qqq_bar.close;
    double high_ratio = (qqq_bar.high - qqq_bar.close) / qqq_bar.close;
    double low_ratio = (qqq_bar.low - qqq_bar.close) / qqq_bar.close;
    
    // Apply leverage factor to intraday movements
    double lev_open_ratio = leverage_data_utils::scale_intraday_movement(
        open_ratio, spec.leverage_factor, spec.is_inverse);
    double lev_high_ratio = leverage_data_utils::scale_intraday_movement(
        high_ratio, spec.leverage_factor, spec.is_inverse);
    double lev_low_ratio = leverage_data_utils::scale_intraday_movement(
        low_ratio, spec.leverage_factor, spec.is_inverse);
    
    // Calculate leveraged OHLC prices
    double lev_open = prev_lev_close * (1.0 + lev_open_ratio);
    double lev_high = prev_lev_close * (1.0 + lev_high_ratio);
    double lev_low = prev_lev_close * (1.0 + lev_low_ratio);
    
    // For inverse ETFs, high and low are swapped
    if (spec.is_inverse) {
        std::swap(lev_high, lev_low);
    }
    
    // Ensure OHLC relationships are maintained
    lev_bar.open = validate_price(lev_open);
    lev_bar.high = validate_price(std::max({lev_open, lev_high}));
    lev_bar.low = validate_price(std::min({lev_open, lev_low}));
    
    // Volume scaling - leverage instruments typically have lower volume
    double volume_scaling = leverage_data_utils::calculate_volume_scaling(spec.leverage_factor);
    lev_bar.volume = static_cast<double>(qqq_bar.volume) * volume_scaling;
    
    return lev_bar;
}

double LeverageDataGenerator::calculate_daily_return(double prev_close, double curr_close) const {
    if (prev_close <= 0.0) {
        return 0.0; // Avoid division by zero
    }
    return (curr_close / prev_close) - 1.0;
}

double LeverageDataGenerator::apply_leverage_factor(double daily_return, 
                                                   const LeverageSpec& spec) const {
    double leveraged_return = daily_return * spec.leverage_factor;
    
    // Apply inversion if necessary
    if (spec.is_inverse) {
        leveraged_return = -leveraged_return;
    }
    
    return leveraged_return;
}

double LeverageDataGenerator::calculate_daily_costs() const {
    return daily_decay_rate_ + daily_expense_rate_;
}

double LeverageDataGenerator::validate_price(double price) const {
    return std::max(0.01, price); // Ensure positive price
}

} // namespace sentio

```

## ðŸ“„ **FILE 38 of 39**: src/backend/leverage_manager.cpp

**File Information**:
- **Path**: `src/backend/leverage_manager.cpp`

- **Size**: 181 lines
- **Modified**: 2025-09-21 20:49:05

- **Type**: .cpp

```text
#include "backend/leverage_manager.h"
#include "common/utils.h"
#include <numeric>
#include <algorithm>
#include <stdexcept>

namespace sentio {

// =============================================================================
// LeveragePositionValidator Implementation
// =============================================================================

LeveragePositionValidator::LeveragePositionValidator() {
    // Define symbols as per requirement 1.1
    long_symbols_ = {"QQQ", "TQQQ"};
    short_symbols_ = {"SQQQ", "PSQ"};
    
    // Define allowed combinations as per corrected requirement 2.2
    // CORRECTED: PSQ + SQQQ is now allowed (both provide short QQQ exposure)
    allowed_combinations_ = {
        {"QQQ"},           // Single long position
        {"TQQQ"},          // Single 3x long position
        {"SQQQ"},          // Single 3x short position
        {"PSQ"},           // Single 1x short position
        {"QQQ", "TQQQ"},   // Dual long positions (amplified long exposure)
        {"PSQ", "SQQQ"}    // Dual short positions (amplified short exposure) - NOW ALLOWED
    };
}

bool LeveragePositionValidator::is_long_qqq(const std::string& symbol) const {
    return long_symbols_.count(symbol) > 0;
}

bool LeveragePositionValidator::is_short_qqq(const std::string& symbol) const {
    return short_symbols_.count(symbol) > 0;
}

bool LeveragePositionValidator::is_leverage_instrument(const std::string& symbol) const {
    return is_long_qqq(symbol) || is_short_qqq(symbol);
}

std::set<std::string> LeveragePositionValidator::get_active_symbols(
    const std::map<std::string, Position>& positions) const {
    
    std::set<std::string> active_symbols;
    for (const auto& pair : positions) {
        if (std::abs(pair.second.quantity) > 1e-6) {
            active_symbols.insert(pair.first);
        }
    }
    return active_symbols;
}

bool LeveragePositionValidator::is_allowed_combination(const std::set<std::string>& symbols) const {
    return allowed_combinations_.count(symbols) > 0;
}

std::string LeveragePositionValidator::generate_conflict_reason(
    const std::string& new_symbol, 
    const std::set<std::string>& active_symbols) const {
    
    // Check for directional conflicts (long + short)
    if (is_long_qqq(new_symbol)) {
        for (const auto& symbol : active_symbols) {
            if (is_short_qqq(symbol)) {
                return "Conflict: Cannot add long exposure (" + new_symbol + 
                       ") to a portfolio with short exposure (" + symbol + ")";
            }
        }
    }
    
    if (is_short_qqq(new_symbol)) {
        for (const auto& symbol : active_symbols) {
            if (is_long_qqq(symbol)) {
                return "Conflict: Cannot add short exposure (" + new_symbol + 
                       ") to a portfolio with long exposure (" + symbol + ")";
            }
        }
    }
    
    // Check for invalid combinations not in whitelist
    return "Conflict: Proposed position combination is not on the allowed whitelist";
}

std::string LeveragePositionValidator::would_cause_conflict(
    const std::string& new_symbol,
    const std::map<std::string, Position>& current_positions) const {
    
    // If the new symbol is not a leverage instrument, no conflict possible
    if (!is_leverage_instrument(new_symbol)) {
        return "";
    }
    
    // Get current active symbols with non-zero quantity
    std::set<std::string> active_symbols = get_active_symbols(current_positions);
    
    // Determine the proposed portfolio state
    std::set<std::string> proposed_symbols = active_symbols;
    proposed_symbols.insert(new_symbol);
    
    // Check against the whitelist (requirement 2.4)
    if (is_allowed_combination(proposed_symbols)) {
        return ""; // No conflict - combination is allowed
    }
    
    // Generate specific conflict reason
    return generate_conflict_reason(new_symbol, active_symbols);
}

// =============================================================================
// LeverageSelector Implementation
// =============================================================================

void LeverageSelector::validate_signal_params(double probability, double confidence) const {
    if (probability < 0.0 || probability > 1.0) {
        throw std::invalid_argument("Signal probability must be between 0.0 and 1.0");
    }
    if (confidence < 0.0 || confidence > 1.0) {
        throw std::invalid_argument("Signal confidence must be between 0.0 and 1.0");
    }
}

bool LeverageSelector::is_bullish_signal(double probability, double confidence) const {
    return probability > 0.6 && confidence > 0.6;
}

bool LeverageSelector::is_bearish_signal(double probability, double confidence) const {
    return probability < 0.4 && confidence > 0.6;
}

bool LeverageSelector::is_neutral_signal(double probability, double confidence) const {
    return !is_bullish_signal(probability, confidence) && 
           !is_bearish_signal(probability, confidence);
}

std::string LeverageSelector::select_optimal_instrument(double probability, double confidence) const {
    // Validate inputs
    validate_signal_params(probability, confidence);
    
    // High confidence bullish signals -> TQQQ (maximum leverage)
    if (probability > 0.7 && confidence > 0.8) {
        return "TQQQ";
    }
    
    // Moderate bullish signals -> QQQ (moderate exposure)
    if (is_bullish_signal(probability, confidence)) {
        return "QQQ";
    }
    
    // High confidence bearish signals -> SQQQ (maximum inverse leverage)
    if (probability < 0.3 && confidence > 0.8) {
        return "SQQQ";
    }
    
    // Moderate bearish signals -> PSQ (moderate inverse exposure)
    if (is_bearish_signal(probability, confidence)) {
        return "PSQ";
    }
    
    // Neutral zone or low confidence -> no recommendation
    return "HOLD";
}

double LeverageSelector::get_leverage_factor(const std::string& symbol) const {
    if (symbol == "TQQQ" || symbol == "SQQQ") {
        return 3.0;
    }
    // QQQ and PSQ have leverage factor of 1.0
    return 1.0;
}

double LeverageSelector::calculate_risk_adjusted_size(const std::string& symbol, 
                                                    double base_position_size) const {
    double leverage_factor = get_leverage_factor(symbol);
    
    // Reduce position size for higher leverage to maintain risk parity
    // This prevents over-leveraging and maintains consistent risk exposure
    return base_position_size / leverage_factor;
}

} // namespace sentio

```

## ðŸ“„ **FILE 39 of 39**: src/backend/portfolio_manager.cpp

**File Information**:
- **Path**: `src/backend/portfolio_manager.cpp`

- **Size**: 194 lines
- **Modified**: 2025-09-21 12:13:34

- **Type**: .cpp

```text
#include "backend/portfolio_manager.h"
#include "common/utils.h"

#include <numeric>
#include <algorithm>

namespace sentio {

PortfolioManager::PortfolioManager(double starting_capital)
    : cash_balance_(starting_capital), realized_pnl_(0.0) {}

bool PortfolioManager::can_buy(const std::string& /*symbol*/, double quantity, double price, double fees) {
    double required_capital = (quantity * price) + fees;
    return cash_balance_ >= required_capital;
}

bool PortfolioManager::can_sell(const std::string& symbol, double quantity) {
    auto it = positions_.find(symbol);
    if (it == positions_.end()) {
        return false;
    }
    return it->second.quantity >= quantity;
}

void PortfolioManager::execute_buy(const std::string& symbol, double quantity,
                                   double price, double fees) {
    double total_cost = (quantity * price) + fees;
    cash_balance_ -= total_cost;
    if (cash_balance_ < -1e-9) {
        utils::log_error("Negative cash after BUY: symbol=" + symbol +
                         ", qty=" + std::to_string(quantity) +
                         ", price=" + std::to_string(price) +
                         ", fees=" + std::to_string(fees) +
                         ", cash_balance=" + std::to_string(cash_balance_));
        std::abort();
    }
    update_position(symbol, quantity, price);
}

void PortfolioManager::execute_sell(const std::string& symbol, double quantity,
                                    double price, double fees) {
    auto it = positions_.find(symbol);
    if (it == positions_.end()) {
        return;
    }

    double proceeds = (quantity * price) - fees;
    cash_balance_ += proceeds;
    if (cash_balance_ < -1e-9) {
        utils::log_error("Negative cash after SELL: symbol=" + symbol +
                         ", qty=" + std::to_string(quantity) +
                         ", price=" + std::to_string(price) +
                         ", fees=" + std::to_string(fees) +
                         ", cash_balance=" + std::to_string(cash_balance_));
        std::abort();
    }

    // Realized P&L
    double gross_pnl = (price - it->second.avg_price) * quantity;
    realized_pnl_ += (gross_pnl - fees);

    // Update or remove position
    if (it->second.quantity > quantity) {
        it->second.quantity -= quantity;
    } else {
        positions_.erase(it);
    }
}

PortfolioState PortfolioManager::get_state() const {
    PortfolioState state;
    state.cash_balance = cash_balance_;
    state.total_equity = get_total_equity();
    state.unrealized_pnl = get_unrealized_pnl();
    state.realized_pnl = realized_pnl_;
    state.positions = positions_;
    state.timestamp_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::system_clock::now().time_since_epoch()).count();
    return state;
}

void PortfolioManager::update_market_prices(const std::map<std::string, double>& prices) {
    for (auto& [symbol, position] : positions_) {
        auto price_it = prices.find(symbol);
        if (price_it != prices.end()) {
            position.current_price = price_it->second;
            position.unrealized_pnl = (position.current_price - position.avg_price) * position.quantity;
        }
    }
}

double PortfolioManager::get_total_equity() const {
    double positions_value = 0.0;
    for (const auto& [symbol, position] : positions_) {
        positions_value += position.quantity * position.current_price;
    }
    return cash_balance_ + positions_value;
}

double PortfolioManager::get_unrealized_pnl() const {
    double total_unrealized = 0.0;
    for (const auto& [symbol, position] : positions_) {
        (void)symbol; // unused
        total_unrealized += position.unrealized_pnl;
    }
    return total_unrealized;
}

bool PortfolioManager::has_position(const std::string& symbol) const {
    return positions_.find(symbol) != positions_.end();
}

Position PortfolioManager::get_position(const std::string& symbol) const {
    auto it = positions_.find(symbol);
    if (it != positions_.end()) {
        return it->second;
    }
    return Position{};
}

void PortfolioManager::update_position(const std::string& symbol,
                                       double quantity, double price) {
    auto it = positions_.find(symbol);
    if (it != positions_.end()) {
        // Average in
        double total_quantity = it->second.quantity + quantity;
        double total_value = (it->second.quantity * it->second.avg_price) + (quantity * price);
        it->second.avg_price = total_value / total_quantity;
        it->second.quantity = total_quantity;
        it->second.current_price = price;
    } else {
        Position pos;
        pos.symbol = symbol;
        pos.quantity = quantity;
        pos.avg_price = price;
        pos.current_price = price;
        pos.unrealized_pnl = 0.0;
        pos.realized_pnl = 0.0;
        positions_[symbol] = pos;
    }
}

// ------------------------- StaticPositionManager -----------------------------
StaticPositionManager::StaticPositionManager()
    : current_direction_(Direction::NEUTRAL), position_count_(0) {}

bool StaticPositionManager::would_cause_conflict(const std::string& symbol,
                                                 TradeAction action) {
    if (action == TradeAction::BUY) {
        bool is_inverse = is_inverse_etf(symbol);
        if (current_direction_ == Direction::SHORT && !is_inverse) {
            return true;
        }
        if (current_direction_ == Direction::LONG && is_inverse) {
            return true;
        }
    }
    return false;
}

void StaticPositionManager::update_direction(Direction new_direction) {
    if (position_count_ == 0) {
        current_direction_ = Direction::NEUTRAL;
    } else {
        current_direction_ = new_direction;
    }
}

void StaticPositionManager::add_position(const std::string& symbol) {
    symbol_positions_[symbol]++;
    position_count_++;
}

void StaticPositionManager::remove_position(const std::string& symbol) {
    auto it = symbol_positions_.find(symbol);
    if (it != symbol_positions_.end()) {
        it->second--;
        if (it->second <= 0) {
            symbol_positions_.erase(it);
        }
        position_count_--;
    }
}

bool StaticPositionManager::is_inverse_etf(const std::string& symbol) const {
    static const std::vector<std::string> inverse_etfs = {
        "PSQ", "SH", "SDS", "SPXS", "SQQQ", "QID", "DXD", "SDOW", "DOG"
    };
    return std::find(inverse_etfs.begin(), inverse_etfs.end(), symbol) != inverse_etfs.end();
}

} // namespace sentio



```

